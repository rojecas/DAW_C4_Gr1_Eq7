{"ast":null,"code":"/*!\r\n * Crypto-JS contribution from Simon Greatrix\r\n */\n(function () {\n  var C = typeof window === 'undefined' ? require('./Crypto').Crypto : window.Crypto; // Create pad namespace\n\n  var C_pad = C.pad = {}; // Calculate the number of padding bytes required.\n\n  function _requiredPadding(cipher, message) {\n    var blockSizeInBytes = cipher._blocksize * 4;\n    var reqd = blockSizeInBytes - message.length % blockSizeInBytes;\n    return reqd;\n  }\n\n  ; // Remove padding when the final byte gives the number of padding bytes.\n\n  var _unpadLength = function (message) {\n    var pad = message.pop();\n\n    for (var i = 1; i < pad; i++) {\n      message.pop();\n    }\n  }; // No-operation padding, used for stream ciphers\n\n\n  C_pad.NoPadding = {\n    pad: function (cipher, message) {},\n    unpad: function (message) {}\n  }; // Zero Padding.\n  //\n  // If the message is not an exact number of blocks, the final block is\n  // completed with 0x00 bytes. There is no unpadding.\n\n  C_pad.ZeroPadding = {\n    pad: function (cipher, message) {\n      var blockSizeInBytes = cipher._blocksize * 4;\n      var reqd = message.length % blockSizeInBytes;\n\n      if (reqd != 0) {\n        for (reqd = blockSizeInBytes - reqd; reqd > 0; reqd--) {\n          message.push(0x00);\n        }\n      }\n    },\n    unpad: function (message) {}\n  }; // ISO/IEC 7816-4 padding.\n  //\n  // Pads the plain text with an 0x80 byte followed by as many 0x00\n  // bytes are required to complete the block.\n\n  C_pad.iso7816 = {\n    pad: function (cipher, message) {\n      var reqd = _requiredPadding(cipher, message);\n\n      message.push(0x80);\n\n      for (; reqd > 1; reqd--) {\n        message.push(0x00);\n      }\n    },\n    unpad: function (message) {\n      while (message.pop() != 0x80) {}\n    }\n  }; // ANSI X.923 padding\n  //\n  // The final block is padded with zeros except for the last byte of the\n  // last block which contains the number of padding bytes.\n\n  C_pad.ansix923 = {\n    pad: function (cipher, message) {\n      var reqd = _requiredPadding(cipher, message);\n\n      for (var i = 1; i < reqd; i++) {\n        message.push(0x00);\n      }\n\n      message.push(reqd);\n    },\n    unpad: _unpadLength\n  }; // ISO 10126\n  //\n  // The final block is padded with random bytes except for the last\n  // byte of the last block which contains the number of padding bytes.\n\n  C_pad.iso10126 = {\n    pad: function (cipher, message) {\n      var reqd = _requiredPadding(cipher, message);\n\n      for (var i = 1; i < reqd; i++) {\n        message.push(Math.floor(Math.random() * 256));\n      }\n\n      message.push(reqd);\n    },\n    unpad: _unpadLength\n  }; // PKCS7 padding\n  //\n  // PKCS7 is described in RFC 5652. Padding is in whole bytes. The\n  // value of each added byte is the number of bytes that are added,\n  // i.e. N bytes, each of value N are added.\n\n  C_pad.pkcs7 = {\n    pad: function (cipher, message) {\n      var reqd = _requiredPadding(cipher, message);\n\n      for (var i = 0; i < reqd; i++) {\n        message.push(reqd);\n      }\n    },\n    unpad: _unpadLength\n  }; // Create mode namespace\n\n  var C_mode = C.mode = {};\n  /**\r\n   * Mode base \"class\".\r\n   */\n\n  var Mode = C_mode.Mode = function (padding) {\n    if (padding) {\n      this._padding = padding;\n    }\n  };\n\n  Mode.prototype = {\n    encrypt: function (cipher, m, iv) {\n      this._padding.pad(cipher, m);\n\n      this._doEncrypt(cipher, m, iv);\n    },\n    decrypt: function (cipher, m, iv) {\n      this._doDecrypt(cipher, m, iv);\n\n      this._padding.unpad(m);\n    },\n    // Default padding\n    _padding: C_pad.iso7816\n  };\n  /**\r\n   * Electronic Code Book mode.\r\n   * \r\n   * ECB applies the cipher directly against each block of the input.\r\n   * \r\n   * ECB does not require an initialization vector.\r\n   */\n\n  var ECB = C_mode.ECB = function () {\n    // Call parent constructor\n    Mode.apply(this, arguments);\n  }; // Inherit from Mode\n\n\n  var ECB_prototype = ECB.prototype = new Mode(); // Concrete steps for Mode template\n\n  ECB_prototype._doEncrypt = function (cipher, m, iv) {\n    var blockSizeInBytes = cipher._blocksize * 4; // Encrypt each block\n\n    for (var offset = 0; offset < m.length; offset += blockSizeInBytes) {\n      cipher._encryptblock(m, offset);\n    }\n  };\n\n  ECB_prototype._doDecrypt = function (cipher, c, iv) {\n    var blockSizeInBytes = cipher._blocksize * 4; // Decrypt each block\n\n    for (var offset = 0; offset < c.length; offset += blockSizeInBytes) {\n      cipher._decryptblock(c, offset);\n    }\n  }; // ECB never uses an IV\n\n\n  ECB_prototype.fixOptions = function (options) {\n    options.iv = [];\n  };\n  /**\r\n   * Cipher block chaining\r\n   * \r\n   * The first block is XORed with the IV. Subsequent blocks are XOR with the\r\n   * previous cipher output.\r\n   */\n\n\n  var CBC = C_mode.CBC = function () {\n    // Call parent constructor\n    Mode.apply(this, arguments);\n  }; // Inherit from Mode\n\n\n  var CBC_prototype = CBC.prototype = new Mode(); // Concrete steps for Mode template\n\n  CBC_prototype._doEncrypt = function (cipher, m, iv) {\n    var blockSizeInBytes = cipher._blocksize * 4; // Encrypt each block\n\n    for (var offset = 0; offset < m.length; offset += blockSizeInBytes) {\n      if (offset == 0) {\n        // XOR first block using IV\n        for (var i = 0; i < blockSizeInBytes; i++) m[i] ^= iv[i];\n      } else {\n        // XOR this block using previous crypted block\n        for (var i = 0; i < blockSizeInBytes; i++) m[offset + i] ^= m[offset + i - blockSizeInBytes];\n      } // Encrypt block\n\n\n      cipher._encryptblock(m, offset);\n    }\n  };\n\n  CBC_prototype._doDecrypt = function (cipher, c, iv) {\n    var blockSizeInBytes = cipher._blocksize * 4; // At the start, the previously crypted block is the IV\n\n    var prevCryptedBlock = iv; // Decrypt each block\n\n    for (var offset = 0; offset < c.length; offset += blockSizeInBytes) {\n      // Save this crypted block\n      var thisCryptedBlock = c.slice(offset, offset + blockSizeInBytes); // Decrypt block\n\n      cipher._decryptblock(c, offset); // XOR decrypted block using previous crypted block\n\n\n      for (var i = 0; i < blockSizeInBytes; i++) {\n        c[offset + i] ^= prevCryptedBlock[i];\n      }\n\n      prevCryptedBlock = thisCryptedBlock;\n    }\n  };\n  /**\r\n   * Cipher feed back\r\n   * \r\n   * The cipher output is XORed with the plain text to produce the cipher output,\r\n   * which is then fed back into the cipher to produce a bit pattern to XOR the\r\n   * next block with.\r\n   * \r\n   * This is a stream cipher mode and does not require padding.\r\n   */\n\n\n  var CFB = C_mode.CFB = function () {\n    // Call parent constructor\n    Mode.apply(this, arguments);\n  }; // Inherit from Mode\n\n\n  var CFB_prototype = CFB.prototype = new Mode(); // Override padding\n\n  CFB_prototype._padding = C_pad.NoPadding; // Concrete steps for Mode template\n\n  CFB_prototype._doEncrypt = function (cipher, m, iv) {\n    var blockSizeInBytes = cipher._blocksize * 4,\n        keystream = iv.slice(0); // Encrypt each byte\n\n    for (var i = 0; i < m.length; i++) {\n      var j = i % blockSizeInBytes;\n      if (j == 0) cipher._encryptblock(keystream, 0);\n      m[i] ^= keystream[j];\n      keystream[j] = m[i];\n    }\n  };\n\n  CFB_prototype._doDecrypt = function (cipher, c, iv) {\n    var blockSizeInBytes = cipher._blocksize * 4,\n        keystream = iv.slice(0); // Encrypt each byte\n\n    for (var i = 0; i < c.length; i++) {\n      var j = i % blockSizeInBytes;\n      if (j == 0) cipher._encryptblock(keystream, 0);\n      var b = c[i];\n      c[i] ^= keystream[j];\n      keystream[j] = b;\n    }\n  };\n  /**\r\n   * Output feed back\r\n   * \r\n   * The cipher repeatedly encrypts its own output. The output is XORed with the\r\n   * plain text to produce the cipher text.\r\n   * \r\n   * This is a stream cipher mode and does not require padding.\r\n   */\n\n\n  var OFB = C_mode.OFB = function () {\n    // Call parent constructor\n    Mode.apply(this, arguments);\n  }; // Inherit from Mode\n\n\n  var OFB_prototype = OFB.prototype = new Mode(); // Override padding\n\n  OFB_prototype._padding = C_pad.NoPadding; // Concrete steps for Mode template\n\n  OFB_prototype._doEncrypt = function (cipher, m, iv) {\n    var blockSizeInBytes = cipher._blocksize * 4,\n        keystream = iv.slice(0); // Encrypt each byte\n\n    for (var i = 0; i < m.length; i++) {\n      // Generate keystream\n      if (i % blockSizeInBytes == 0) cipher._encryptblock(keystream, 0); // Encrypt byte\n\n      m[i] ^= keystream[i % blockSizeInBytes];\n    }\n  };\n\n  OFB_prototype._doDecrypt = OFB_prototype._doEncrypt;\n  /**\r\n   * Counter\r\n   * @author Gergely Risko\r\n   *\r\n   * After every block the last 4 bytes of the IV is increased by one\r\n   * with carry and that IV is used for the next block.\r\n   *\r\n   * This is a stream cipher mode and does not require padding.\r\n   */\n\n  var CTR = C_mode.CTR = function () {\n    // Call parent constructor\n    Mode.apply(this, arguments);\n  }; // Inherit from Mode\n\n\n  var CTR_prototype = CTR.prototype = new Mode(); // Override padding\n\n  CTR_prototype._padding = C_pad.NoPadding;\n\n  CTR_prototype._doEncrypt = function (cipher, m, iv) {\n    var blockSizeInBytes = cipher._blocksize * 4;\n    var counter = iv.slice(0);\n\n    for (var i = 0; i < m.length;) {\n      // do not lose iv\n      var keystream = counter.slice(0); // Generate keystream for next block\n\n      cipher._encryptblock(keystream, 0); // XOR keystream with block\n\n\n      for (var j = 0; i < m.length && j < blockSizeInBytes; j++, i++) {\n        m[i] ^= keystream[j];\n      } // Increase counter\n\n\n      if (++counter[blockSizeInBytes - 1] == 256) {\n        counter[blockSizeInBytes - 1] = 0;\n\n        if (++counter[blockSizeInBytes - 2] == 256) {\n          counter[blockSizeInBytes - 2] = 0;\n\n          if (++counter[blockSizeInBytes - 3] == 256) {\n            counter[blockSizeInBytes - 3] = 0;\n            ++counter[blockSizeInBytes - 4];\n          }\n        }\n      }\n    }\n  };\n\n  CTR_prototype._doDecrypt = CTR_prototype._doEncrypt;\n})();","map":{"version":3,"names":["C","window","require","Crypto","C_pad","pad","_requiredPadding","cipher","message","blockSizeInBytes","_blocksize","reqd","length","_unpadLength","pop","i","NoPadding","unpad","ZeroPadding","push","iso7816","ansix923","iso10126","Math","floor","random","pkcs7","C_mode","mode","Mode","padding","_padding","prototype","encrypt","m","iv","_doEncrypt","decrypt","_doDecrypt","ECB","apply","arguments","ECB_prototype","offset","_encryptblock","c","_decryptblock","fixOptions","options","CBC","CBC_prototype","prevCryptedBlock","thisCryptedBlock","slice","CFB","CFB_prototype","keystream","j","b","OFB","OFB_prototype","CTR","CTR_prototype","counter"],"sources":["D:/MySource/DAW_C4_Gr1_Eq7/FrontEndMF/node_modules/cryptojs/lib/BlockModes.js"],"sourcesContent":["/*!\r\n * Crypto-JS contribution from Simon Greatrix\r\n */\r\n\r\n(function(){\r\n\r\nvar C = (typeof window === 'undefined') ? require('./Crypto').Crypto : window.Crypto;\r\n\r\n// Create pad namespace\r\nvar C_pad = C.pad = {};\r\n\r\n// Calculate the number of padding bytes required.\r\nfunction _requiredPadding(cipher, message) {\r\n    var blockSizeInBytes = cipher._blocksize * 4;\r\n    var reqd = blockSizeInBytes - message.length % blockSizeInBytes;\r\n    return reqd;\r\n};\r\n\r\n// Remove padding when the final byte gives the number of padding bytes.\r\nvar _unpadLength = function (message) {\r\n        var pad = message.pop();\r\n        for (var i = 1; i < pad; i++) {\r\n            message.pop();\r\n        }\r\n    };\r\n\r\n// No-operation padding, used for stream ciphers\r\nC_pad.NoPadding = {\r\n        pad : function (cipher,message) {},\r\n        unpad : function (message) {}\r\n    };\r\n\r\n// Zero Padding.\r\n//\r\n// If the message is not an exact number of blocks, the final block is\r\n// completed with 0x00 bytes. There is no unpadding.\r\nC_pad.ZeroPadding = {\r\n    pad : function (cipher, message) {\r\n        var blockSizeInBytes = cipher._blocksize * 4;\r\n        var reqd = message.length % blockSizeInBytes;\r\n        if( reqd!=0 ) {\r\n            for(reqd = blockSizeInBytes - reqd; reqd>0; reqd--) {\r\n                message.push(0x00);\r\n            }\r\n        }\r\n    },\r\n\r\n    unpad : function (message) {}\r\n};\r\n\r\n// ISO/IEC 7816-4 padding.\r\n//\r\n// Pads the plain text with an 0x80 byte followed by as many 0x00\r\n// bytes are required to complete the block.\r\nC_pad.iso7816 = {\r\n    pad : function (cipher, message) {\r\n        var reqd = _requiredPadding(cipher, message);\r\n        message.push(0x80);\r\n        for (; reqd > 1; reqd--) {\r\n            message.push(0x00);\r\n        }\r\n    },\r\n\r\n    unpad : function (message) {\r\n        while (message.pop() != 0x80) {}\r\n    }\r\n};\r\n\r\n// ANSI X.923 padding\r\n//\r\n// The final block is padded with zeros except for the last byte of the\r\n// last block which contains the number of padding bytes.\r\nC_pad.ansix923 = {\r\n    pad : function (cipher, message) {\r\n        var reqd = _requiredPadding(cipher, message);\r\n        for (var i = 1; i < reqd; i++) {\r\n            message.push(0x00);\r\n        }\r\n        message.push(reqd);\r\n    },\r\n\r\n    unpad : _unpadLength\r\n};\r\n\r\n// ISO 10126\r\n//\r\n// The final block is padded with random bytes except for the last\r\n// byte of the last block which contains the number of padding bytes.\r\nC_pad.iso10126 = {\r\n    pad : function (cipher, message) {\r\n        var reqd = _requiredPadding(cipher, message);\r\n        for (var i = 1; i < reqd; i++) {\r\n            message.push(Math.floor(Math.random() * 256));\r\n        }\r\n        message.push(reqd);\r\n    },\r\n\r\n    unpad : _unpadLength\r\n};\r\n\r\n// PKCS7 padding\r\n//\r\n// PKCS7 is described in RFC 5652. Padding is in whole bytes. The\r\n// value of each added byte is the number of bytes that are added,\r\n// i.e. N bytes, each of value N are added.\r\nC_pad.pkcs7 = {\r\n    pad : function (cipher, message) {\r\n        var reqd = _requiredPadding(cipher, message);\r\n        for (var i = 0; i < reqd; i++) {\r\n            message.push(reqd);\r\n        }\r\n    },\r\n\r\n    unpad : _unpadLength\r\n};\r\n\r\n// Create mode namespace\r\nvar C_mode = C.mode = {};\r\n\r\n/**\r\n * Mode base \"class\".\r\n */\r\nvar Mode = C_mode.Mode = function (padding) {\r\n    if (padding) {\r\n        this._padding = padding;\r\n    }\r\n};\r\n\r\nMode.prototype = {\r\n    encrypt: function (cipher, m, iv) {\r\n        this._padding.pad(cipher, m);\r\n        this._doEncrypt(cipher, m, iv);\r\n    },\r\n\r\n    decrypt: function (cipher, m, iv) {\r\n        this._doDecrypt(cipher, m, iv);\r\n        this._padding.unpad(m);\r\n    },\r\n\r\n    // Default padding\r\n    _padding: C_pad.iso7816\r\n};\r\n\r\n\r\n/**\r\n * Electronic Code Book mode.\r\n * \r\n * ECB applies the cipher directly against each block of the input.\r\n * \r\n * ECB does not require an initialization vector.\r\n */\r\nvar ECB = C_mode.ECB = function () {\r\n    // Call parent constructor\r\n    Mode.apply(this, arguments);\r\n};\r\n\r\n// Inherit from Mode\r\nvar ECB_prototype = ECB.prototype = new Mode;\r\n\r\n// Concrete steps for Mode template\r\nECB_prototype._doEncrypt = function (cipher, m, iv) {\r\n    var blockSizeInBytes = cipher._blocksize * 4;\r\n    // Encrypt each block\r\n    for (var offset = 0; offset < m.length; offset += blockSizeInBytes) {\r\n        cipher._encryptblock(m, offset);\r\n    }\r\n};\r\nECB_prototype._doDecrypt = function (cipher, c, iv) {\r\n    var blockSizeInBytes = cipher._blocksize * 4;\r\n    // Decrypt each block\r\n    for (var offset = 0; offset < c.length; offset += blockSizeInBytes) {\r\n        cipher._decryptblock(c, offset);\r\n    }\r\n};\r\n\r\n// ECB never uses an IV\r\nECB_prototype.fixOptions = function (options) {\r\n    options.iv = [];\r\n};\r\n\r\n\r\n/**\r\n * Cipher block chaining\r\n * \r\n * The first block is XORed with the IV. Subsequent blocks are XOR with the\r\n * previous cipher output.\r\n */\r\nvar CBC = C_mode.CBC = function () {\r\n    // Call parent constructor\r\n    Mode.apply(this, arguments);\r\n};\r\n\r\n// Inherit from Mode\r\nvar CBC_prototype = CBC.prototype = new Mode;\r\n\r\n// Concrete steps for Mode template\r\nCBC_prototype._doEncrypt = function (cipher, m, iv) {\r\n    var blockSizeInBytes = cipher._blocksize * 4;\r\n\r\n    // Encrypt each block\r\n    for (var offset = 0; offset < m.length; offset += blockSizeInBytes) {\r\n        if (offset == 0) {\r\n            // XOR first block using IV\r\n            for (var i = 0; i < blockSizeInBytes; i++)\r\n            m[i] ^= iv[i];\r\n        } else {\r\n            // XOR this block using previous crypted block\r\n            for (var i = 0; i < blockSizeInBytes; i++)\r\n            m[offset + i] ^= m[offset + i - blockSizeInBytes];\r\n        }\r\n        // Encrypt block\r\n        cipher._encryptblock(m, offset);\r\n    }\r\n};\r\nCBC_prototype._doDecrypt = function (cipher, c, iv) {\r\n    var blockSizeInBytes = cipher._blocksize * 4;\r\n\r\n    // At the start, the previously crypted block is the IV\r\n    var prevCryptedBlock = iv;\r\n\r\n    // Decrypt each block\r\n    for (var offset = 0; offset < c.length; offset += blockSizeInBytes) {\r\n        // Save this crypted block\r\n        var thisCryptedBlock = c.slice(offset, offset + blockSizeInBytes);\r\n        // Decrypt block\r\n        cipher._decryptblock(c, offset);\r\n        // XOR decrypted block using previous crypted block\r\n        for (var i = 0; i < blockSizeInBytes; i++) {\r\n            c[offset + i] ^= prevCryptedBlock[i];\r\n        }\r\n        prevCryptedBlock = thisCryptedBlock;\r\n    }\r\n};\r\n\r\n\r\n/**\r\n * Cipher feed back\r\n * \r\n * The cipher output is XORed with the plain text to produce the cipher output,\r\n * which is then fed back into the cipher to produce a bit pattern to XOR the\r\n * next block with.\r\n * \r\n * This is a stream cipher mode and does not require padding.\r\n */\r\nvar CFB = C_mode.CFB = function () {\r\n    // Call parent constructor\r\n    Mode.apply(this, arguments);\r\n};\r\n\r\n// Inherit from Mode\r\nvar CFB_prototype = CFB.prototype = new Mode;\r\n\r\n// Override padding\r\nCFB_prototype._padding = C_pad.NoPadding;\r\n\r\n// Concrete steps for Mode template\r\nCFB_prototype._doEncrypt = function (cipher, m, iv) {\r\n    var blockSizeInBytes = cipher._blocksize * 4,\r\n        keystream = iv.slice(0);\r\n\r\n    // Encrypt each byte\r\n    for (var i = 0; i < m.length; i++) {\r\n\r\n        var j = i % blockSizeInBytes;\r\n        if (j == 0) cipher._encryptblock(keystream, 0);\r\n\r\n        m[i] ^= keystream[j];\r\n        keystream[j] = m[i];\r\n    }\r\n};\r\nCFB_prototype._doDecrypt = function (cipher, c, iv) {\r\n    var blockSizeInBytes = cipher._blocksize * 4,\r\n        keystream = iv.slice(0);\r\n\r\n    // Encrypt each byte\r\n    for (var i = 0; i < c.length; i++) {\r\n\r\n        var j = i % blockSizeInBytes;\r\n        if (j == 0) cipher._encryptblock(keystream, 0);\r\n\r\n        var b = c[i];\r\n        c[i] ^= keystream[j];\r\n        keystream[j] = b;\r\n    }\r\n};\r\n\r\n\r\n/**\r\n * Output feed back\r\n * \r\n * The cipher repeatedly encrypts its own output. The output is XORed with the\r\n * plain text to produce the cipher text.\r\n * \r\n * This is a stream cipher mode and does not require padding.\r\n */\r\nvar OFB = C_mode.OFB = function () {\r\n    // Call parent constructor\r\n    Mode.apply(this, arguments);\r\n};\r\n\r\n// Inherit from Mode\r\nvar OFB_prototype = OFB.prototype = new Mode;\r\n\r\n// Override padding\r\nOFB_prototype._padding = C_pad.NoPadding;\r\n\r\n// Concrete steps for Mode template\r\nOFB_prototype._doEncrypt = function (cipher, m, iv) {\r\n\r\n    var blockSizeInBytes = cipher._blocksize * 4,\r\n        keystream = iv.slice(0);\r\n\r\n    // Encrypt each byte\r\n    for (var i = 0; i < m.length; i++) {\r\n\r\n        // Generate keystream\r\n        if (i % blockSizeInBytes == 0)\r\n            cipher._encryptblock(keystream, 0);\r\n\r\n        // Encrypt byte\r\n        m[i] ^= keystream[i % blockSizeInBytes];\r\n\r\n    }\r\n};\r\nOFB_prototype._doDecrypt = OFB_prototype._doEncrypt;\r\n\r\n/**\r\n * Counter\r\n * @author Gergely Risko\r\n *\r\n * After every block the last 4 bytes of the IV is increased by one\r\n * with carry and that IV is used for the next block.\r\n *\r\n * This is a stream cipher mode and does not require padding.\r\n */\r\nvar CTR = C_mode.CTR = function () {\r\n    // Call parent constructor\r\n    Mode.apply(this, arguments);\r\n};\r\n\r\n// Inherit from Mode\r\nvar CTR_prototype = CTR.prototype = new Mode;\r\n\r\n// Override padding\r\nCTR_prototype._padding = C_pad.NoPadding;\r\n\r\nCTR_prototype._doEncrypt = function (cipher, m, iv) {\r\n    var blockSizeInBytes = cipher._blocksize * 4;\r\n    var counter = iv.slice(0);\r\n\r\n    for (var i = 0; i < m.length;) {\r\n        // do not lose iv\r\n        var keystream = counter.slice(0);\r\n\r\n        // Generate keystream for next block\r\n        cipher._encryptblock(keystream, 0);\r\n\r\n        // XOR keystream with block\r\n        for (var j = 0; i < m.length && j < blockSizeInBytes; j++, i++) {\r\n            m[i] ^= keystream[j];\r\n        }\r\n\r\n        // Increase counter\r\n        if(++(counter[blockSizeInBytes-1]) == 256) {\r\n            counter[blockSizeInBytes-1] = 0;\r\n            if(++(counter[blockSizeInBytes-2]) == 256) {\r\n                counter[blockSizeInBytes-2] = 0;\r\n                if(++(counter[blockSizeInBytes-3]) == 256) {\r\n                    counter[blockSizeInBytes-3] = 0;\r\n                    ++(counter[blockSizeInBytes-4]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\nCTR_prototype._doDecrypt = CTR_prototype._doEncrypt;\r\n\r\n})();\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}