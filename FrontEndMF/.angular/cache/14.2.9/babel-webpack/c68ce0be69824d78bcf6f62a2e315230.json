{"ast":null,"code":"(function () {\n  var C = typeof window === 'undefined' ? require('./Crypto').Crypto : window.Crypto; // Shortcuts\n\n  var util = C.util,\n      charenc = C.charenc,\n      UTF8 = charenc.UTF8,\n      Binary = charenc.Binary;\n\n  if (!C.nextTick) {\n    // node.js has setTime out but prefer process.nextTick\n    if (typeof process != 'undefined' && typeof process.nextTick !== 'undefined') {\n      C.nextTick = process.nextTick;\n    } else if (typeof setTimeout !== 'undefined') {\n      C.nextTick = function (callback) {\n        setTimeout(callback, 0);\n      };\n    }\n  }\n\n  C.PBKDF2Async = function (password, salt, keylen, callback, options) {\n    // Convert to byte arrays\n    if (password.constructor == String) password = UTF8.stringToBytes(password);\n    if (salt.constructor == String) salt = UTF8.stringToBytes(salt);\n    /* else, assume byte arrays already */\n    // Defaults\n\n    var hasher = options && options.hasher || C.SHA1,\n        iterations = options && options.iterations || 1; // Progress callback option\n\n    var progressChangeHandler = options && options.onProgressChange;\n    var totalIterations = Math.ceil(keylen / hasher._digestsize) * iterations;\n\n    function fireProgressChange(currentIteration) {\n      if (progressChangeHandler) {\n        var iterationsSoFar = derivedKeyBytes.length / hasher._digestsize * iterations + currentIteration;\n        setTimeout(function () {\n          progressChangeHandler(Math.round(iterationsSoFar / totalIterations * 100));\n        }, 0);\n      }\n    } // Pseudo-random function\n\n\n    function PRF(password, salt) {\n      return C.HMAC(hasher, salt, password, {\n        asBytes: true\n      });\n    }\n\n    var nextTick = C.nextTick; // Generate key\n\n    var derivedKeyBytes = [],\n        blockindex = 1;\n    var outer, inner;\n    nextTick(outer = function () {\n      if (derivedKeyBytes.length < keylen) {\n        var block = PRF(password, salt.concat(util.wordsToBytes([blockindex])));\n        fireProgressChange(1);\n        var u = block,\n            i = 1;\n        nextTick(inner = function () {\n          if (i < iterations) {\n            u = PRF(password, u);\n\n            for (var j = 0; j < block.length; j++) block[j] ^= u[j];\n\n            i++;\n            fireProgressChange(i);\n            nextTick(inner);\n          } else {\n            derivedKeyBytes = derivedKeyBytes.concat(block);\n            blockindex++;\n            nextTick(outer);\n          }\n        });\n      } else {\n        // Truncate excess bytes\n        derivedKeyBytes.length = keylen;\n        callback(options && options.asBytes ? derivedKeyBytes : options && options.asString ? Binary.bytesToString(derivedKeyBytes) : util.bytesToHex(derivedKeyBytes));\n      }\n    });\n  };\n})();","map":{"version":3,"names":["C","window","require","Crypto","util","charenc","UTF8","Binary","nextTick","process","setTimeout","callback","PBKDF2Async","password","salt","keylen","options","constructor","String","stringToBytes","hasher","SHA1","iterations","progressChangeHandler","onProgressChange","totalIterations","Math","ceil","_digestsize","fireProgressChange","currentIteration","iterationsSoFar","derivedKeyBytes","length","round","PRF","HMAC","asBytes","blockindex","outer","inner","block","concat","wordsToBytes","u","i","j","asString","bytesToString","bytesToHex"],"sources":["D:/MySource/DAW_C4_Gr1_Eq7/FrontEndMF/node_modules/cryptojs/lib/PBKDF2Async.js"],"sourcesContent":["(function(){\r\n\r\nvar C = (typeof window === 'undefined') ? require('./Crypto').Crypto : window.Crypto;\r\n\r\n// Shortcuts\r\nvar util = C.util,\r\n    charenc = C.charenc,\r\n    UTF8 = charenc.UTF8,\r\n    Binary = charenc.Binary;\r\n\r\nif (!C.nextTick) {\r\n    // node.js has setTime out but prefer process.nextTick\r\n    if (typeof process != 'undefined' && typeof process.nextTick !== 'undefined') {\r\n        C.nextTick = process.nextTick;\r\n    } else if (typeof setTimeout !== 'undefined') {\r\n        C.nextTick = function (callback) {\r\n            setTimeout(callback, 0);\r\n        };\r\n    }\r\n}\r\n\r\nC.PBKDF2Async = function (password, salt, keylen, callback, options) {\r\n\r\n    // Convert to byte arrays\r\n    if (password.constructor == String) password = UTF8.stringToBytes(password);\r\n    if (salt.constructor == String) salt = UTF8.stringToBytes(salt);\r\n    /* else, assume byte arrays already */\r\n\r\n    // Defaults\r\n    var hasher = options && options.hasher || C.SHA1,\r\n        iterations = options && options.iterations || 1;\r\n\r\n    // Progress callback option\r\n    var progressChangeHandler = options && options.onProgressChange;\r\n    var totalIterations = Math.ceil(keylen / hasher._digestsize) * iterations;\r\n    function fireProgressChange(currentIteration) {\r\n        if (progressChangeHandler) {\r\n            var iterationsSoFar = derivedKeyBytes.length / hasher._digestsize * iterations + currentIteration;\r\n            setTimeout(function () {\r\n                progressChangeHandler(Math.round(iterationsSoFar / totalIterations * 100));\r\n            }, 0);\r\n        }\r\n    }\r\n\r\n    // Pseudo-random function\r\n    function PRF(password, salt) {\r\n        return C.HMAC(hasher, salt, password, { asBytes: true });\r\n    }\r\n\r\n    var nextTick = C.nextTick;\r\n\r\n    // Generate key\r\n    var derivedKeyBytes = [],\r\n        blockindex = 1;\r\n\r\n    var outer, inner;\r\n    nextTick(outer = function () {\r\n        if (derivedKeyBytes.length < keylen) {\r\n            var block = PRF(password, salt.concat(util.wordsToBytes([blockindex])));\r\n            fireProgressChange(1);\r\n\r\n            var u = block, i = 1;\r\n            nextTick(inner = function () {\r\n                if (i < iterations) {\r\n                    u = PRF(password, u);\r\n                    for (var j = 0; j < block.length; j++) block[j] ^= u[j];\r\n                    i++;\r\n                    fireProgressChange(i);\r\n\r\n                    nextTick(inner);\r\n                } else {\r\n                    derivedKeyBytes = derivedKeyBytes.concat(block);\r\n                    blockindex++;\r\n                    nextTick(outer);\r\n                }\r\n            });\r\n        } else {\r\n            // Truncate excess bytes\r\n            derivedKeyBytes.length = keylen;\r\n            callback(\r\n                    options && options.asBytes ? derivedKeyBytes :\r\n                    options && options.asString ? Binary.bytesToString(derivedKeyBytes) :\r\n                    util.bytesToHex(derivedKeyBytes));\r\n        }\r\n    });\r\n};\r\n\r\n})();\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}